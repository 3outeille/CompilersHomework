# Lab2 report

2019.10.9

## Main ideas

The task of lab2 is to generate a syntax tree from C- source file using bison.

As the parser is going to get token stream from result generated by flex, I choose to let flex initialize tree nodes(more precisely, tree leaf tokens), and use bison action rules to generate other nodes and add those leaf tokens to the tree. 

I use union which contains a `SyntaxTree * node` to share data structure between bison and flex. For each valid token found by flex, a node(leaf) is created. For each rule like `A -> B C D` in bison, a node is created for `A`, and `B`, `C` and `D` are added as children of `A`. So after doing all the reduction, a whole syntax tree is generated, with `program` in the first statement containing the tree root. 

## Shift-reduce conflict in if-else statement

The given syntax about C- contains a shift-reduce conflict (and bison gives a warning): 

selection-stmt â†’ `if` `(` expression `)` statement | `if` `(` expression `)` statement `else` statement

We don't know whether to shift in `else` or reduce using the first part of the rule. 

To solve this, we can figure out better rules(maybe adding more statements) or give the shift and reduce an priority. Here I used the method discussed on GitLab(by iBug and Ray-Lei) and [stackoverflow](https://stackoverflow.com/questions/12731922/reforming-the-grammar-to-remove-shift-reduce-conflict-in-if-then-else): tell the parser to shift in `else` when the conflict occurs. And `else` will be binded to the closest `if`. 

After this, the conflict is solved and we can see from the syntax tree that the behavior is same as expected.

Picture: a part of a syntax tree, showing how `if() if() else` is parsed. 

![](./ifelsetree.png)

## (Lamed) visualization

To show the procedure of tree-building, the tree should be printed during analysis. I print the tree using the node for the left non-terminal as the tree root. So the tree at the current time is printed, and we can see how the tree grows when more reductions are made. But this is a really lamed solution, because during analysis, the tokens actually form a **forest** instead of a single **tree**, and printing the single tree only shows the newly analyzed fraction of the whole picture. 

And how to visualize the tree? I first tried LaTeX, but later find python to be a better tool. I used a package called `svgling` which can draw trees. I wrote a function to generate a python script and print those trees in the `svgling` format(using a modified function like `printSyntaxTreeNode`). Then run the python script in jupyter, and we can see all those(some of them really big) trees. Like the example `syntree/trees.ipynb`

The result of the final tree is really good, as is shown below.

A shot of the final of the gcd.cminus tree(the original svg picture is more than 6000 pixel in width):

![](./gcdtreeshot.png)

First subtree in gcd:

![](./gcdtreesmall.png)

## TODO & further improvement?

To avoid useless tokens like `COMMENT` or `NEWLINE`, I just remove actions which are related to these tokens in flex because I didn't find a better solution. So parts of the code in lab1 is modified and deleted, though I made backup, this makes the program somewhat less backward compatible. 

Also, I didn't find any better way(after searching on the Internet and consulting students) to write the actions in bison(those to build tree) in an elegant way. You can find that the code in `syntax_analyzer.y` is really in bad condition, codes are repetitious and long thus difficult to maintain. Though recording editor macros and replacing with (complex) regular expression in VIM make the work easier, I still found this process disturbing. 

The visualization is lamed, and better way is needed, though I think further work(maybe even animation) on this won't be easy. 

I feel that my whole project is a little bit messy, but don't know what to do about it :-(

## Timing

~1.5h get familiar with what to do

~1h learn bison

~0.5h try to learn cmake

~0.5h modify the flex parts

~1.5h write the bison parts

~1h solving small problems and debugging

~2h visualization

~1.5h code cleanup, and report. 